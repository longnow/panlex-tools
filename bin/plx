#!/usr/bin/env perl
use strict;
use warnings 'FATAL', 'all';
use utf8;
use open IO => ':raw :encoding(utf8)';
binmode STDOUT, ':encoding(utf8)';
binmode STDERR, ':encoding(utf8)';

use File::Spec::Functions qw/catdir catfile curdir rel2abs splitdir/;
use LWP::UserAgent;
use Encode 'encode';
use Unicode::Normalize;

use lib "$ENV{PANLEX_TOOLDIR}/lib";
use PanLex::Client;

my $RESOURCE_ARCHIVE_URL = 'http://dev.panlex.org/resources';
my $PANLEM_URL = 'http://panlex.org/u';

usage(), exit(0) unless @ARGV;

utf8::decode($_) for @ARGV;
my $cmd = shift @ARGV;
my $cmd_sub = __PACKAGE__->can('cmd_'.$cmd);

if ($cmd_sub) {
    $cmd_sub->(@ARGV);
} else {
    print STDERR "Unknown command: $cmd\n\n";
    usage();
}

sub cmd_cp {
    my ($tool, $dest) = @_;

    print(STDERR "You need to specify a tool.\n"), return unless $tool;

    my $sourcedir = rel2abs(curdir());
    utf8::decode($sourcedir);

    my $source;
    foreach my $dir (reverse splitdir($sourcedir)) {
        if ($dir =~ /^[a-z]{3}-/) {
            $source = $dir;
            last;
        }
    }
    $source //= 'aaa-bbb-Author';

    cp_makefile($source), return if $tool =~ /^makefile$/i;

    $tool .= '.pl' unless $tool =~ /\./;
    $dest //= $tool;

    foreach my $dir ( ['serialize'], ['serialize', 'data'], ['tabularize', 'util'] ) {
        my $file = catfile($ENV{PANLEX_TOOLDIR}, @$dir, $tool);
        
        if (-e $file) {
            cp_file($file, $dest, $source);
            return;
        }
    }

    my @tabularize = glob(catfile($ENV{PANLEX_TOOLDIR}, 'tabularize', '*', $tool));
    
    if (@tabularize) {
        cp_file($tabularize[0], "${source}.${dest}", $source);
        return;
    }
    
    print STDERR "could not find panlex tool $tool\n";
}

sub cp_file {
    my ($source_file, $target_file, $source_label) = @_;

    print(STDERR "$target_file already exists, aborting\n"), return if -e $target_file;

    open my $fd, '<', $source_file or die $!;
    my $data = do { local $/; <$fd> };
    close $fd;
    
    $data =~ s/aaa-bbb-Author/$source_label/;
    
    open $fd, '>', $target_file or die $!;
    print $fd $data;
    close $fd;
    
    my $mode = (stat($source_file))[2] & 07777;
    chmod $mode, $target_file;
}

sub cp_makefile {
    my ($source) = @_;

    my $fromfile = get_glob("${source}-0.*");

    my (@deps, $tab);

    if ($tab = get_glob('tabularize-*.*')) {
        die "can't find file matching pattern ${source}-0.*" unless defined $fromfile;
        push @deps, [ "${source}-1.txt", [ $fromfile, $tab ], add_interp($tab) ];
    } else {
        if ($tab = get_glob('*-scrape.*')) {
            $fromfile = get_glob("${source}.*");
            die "can't find file matching pattern ${source}.*" unless defined $fromfile;
            push @deps, [ "${source}-0.txt", [ $fromfile, $tab ], add_interp($tab) ];
            $fromfile = "${source}-0.txt";
        }

        my ($x, $y) = (0, 1);

        while ($tab = get_glob("*${x}to${y}.*")) {
            push @deps, [ "${source}-${y}.txt", [ $fromfile, $tab ], add_interp($tab) ];
            $fromfile = "${source}-${y}.txt";
            $x++, $y++;
        }
    }

    my @tabs = map { $_->[0] } @deps;
    my $firstser = $deps[-1][0] =~ s/^.+-([0-9]+)\.txt$/$1/r;
    $firstser++;

    push @deps, [ "${source}-final.txt", [ $deps[-1][0], 'serialize.pl' ], 'perl serialize.pl' ]; 

    open my $fd, '>', 'Makefile' or die $!;

    print $fd "SHELL = /bin/bash\n\n";
    print $fd "all: tab ser\n\n";
    print $fd "tab: @tabs\n\n";
    print $fd "ser: ${source}-final.txt\n\n";
    print $fd "clean:\n\trm -f @tabs ${source}-{${firstser}..50}.txt ${source}-final.txt\n\n";

    foreach my $d (@deps) {
        print $fd "$d->[0]: @{$d->[1]}\n\t$d->[2]\n\n";
    }

    close $fd;
}

sub get_glob {
    my ($pattern) = @_;
    my $file = (glob($pattern))[0];
    return $file unless defined $file;
    utf8::decode($file);
    return $file;
}

sub add_interp {
    my ($filename) = @_;

    my $interp;

    if ($filename =~ /\.pl$/) {
        $interp = 'perl';
    } elsif ($filename =~ /\.py$/) {
        $interp = 'python3';
    } elsif ($filename =~ /\.js$/) {
        $interp = 'node';
    } else {
        die "don't know what interpreter to use for $filename";
    }

    return "$interp $filename";
}

sub cmd_fetch {
    my ($source) = @_;

    print(STDERR "You need to specify a source directory, label, or ID.\n"), return unless $source;
    check_env(qw/PANLEX_ARCHIVE_USERNAME PANLEX_ARCHIVE_PASSWORD/);

    if ($source =~ /:|^\d+$/) {
        print(STDERR "Looking up source directory from label/ID ...\n");

        my $result = panlex_query("/ap/$source");
        $source = $result->{ap}{fp};
        die "could not find source directory" unless defined $source;
        print STDERR "$source\n\n";
    }

    my $ua = LWP::UserAgent->new;
    $ua->credentials('dev.panlex.org:80', 'PanLex resource browser', $ENV{PANLEX_ARCHIVE_USERNAME}, $ENV{PANLEX_ARCHIVE_PASSWORD});

    my $r;

    foreach my $dir (qw/ incoming main /) {
        my $url = "${RESOURCE_ARCHIVE_URL}/download/${dir}/${source}.zip";
        $r = $ua->get($url);

        if ($r->is_success) {
            print STDERR "Fetched $url\n";

            my $zip = $r->filename;
            utf8::decode($zip);
            open my $out, '>:raw', $zip or die $!;
            print $out $r->decoded_content;
            close $out;

            my $dir = $zip;
            $dir =~ s/\.zip$//;

            if (-e $dir) {
                print STDERR "Directory $dir already exists, not extracting $zip\n";
            }
            else {
                print STDERR "Extracting $zip ...\n";
                system('unzip', $zip) == 0 && unlink $zip;
            }

            return;
        }
    }

    print STDERR "Could not fetch source $source: ", $r->code, ' ', $r->message, "\n";
}

sub cmd_submit {
    my ($final, $ap, $aptt);
    my $sr = 'dossnd1'; # submit file
    my $op = '2'; # replace

    if (defined $_[0] && -f $_[0]) {
        $final = shift;
    } else {
        $final = glob('*-final.txt');
        print(STDERR "Could not locate final source file.\n"), return unless defined $final;
        utf8::decode($final);
    }

    foreach my $arg (@_) {
        if ($arg eq 'check') {
            $op = '0';
        } elsif ($arg eq 'add') {
            $op = '1';
        } elsif ($arg =~ /^\d+$/) {
            $ap //= $arg;
        } elsif ($arg =~ /:/) {
            $aptt //= $arg;
        }
    }

    check_env(qw/PANLEX_PANLEM_USER PANLEX_PANLEM_PASSWORD/);

    if (!defined $ap) {
        print STDERR "No source id argument provided, trying to look it up ...\n";

        if (!defined $aptt) {
            my $dirname = (splitdir(rel2abs(curdir())))[-1];
            utf8::decode($dirname);

            print(STDERR "Unable to infer source label from directory name: $dirname\n"), return
                unless $dirname =~ /^([a-z]{3}(?:-[a-z]{3})*)-(.+?)$/;

            $aptt = NFC("$1:$2");
        }

        my $result = panlex_query("/ap/$aptt");
        $ap = $result->{ap}{ap};
        print STDERR "$ap\n\n";
    }

    print "Submitting $final to PanLem ...\n";

    my $ua = LWP::UserAgent->new;
    $ua->timeout(1800);
    $ua->show_progress(1);

    my $r = $ua->post($PANLEM_URL,
        Content_Type => 'form-data',
        Content => [
            us      => $ENV{PANLEX_PANLEM_USER},
            pwd     => "'$ENV{PANLEX_PANLEM_PASSWORD}'",
            uslv    => '187', # user's interface lv
            sr      => $sr, # state routine
            op      => $op, # operation
            ap      => $ap, # source id
            dbg     => '', # whole - see
            ml      => 'res', # multiline parameter (must be ordered before the parameter)
            res     => [encode('utf8', $final), undef], # uploaded file
        ]
    );

    if ($r->is_success) {
        my $content = $r->decoded_content;

        if ($content =~ /"bad"/) {
            print STDERR "failed: are your username and password set correctly, and are you approved to edit the source?\n\n";
        } else {
            print STDERR "done.\n\n";
        }
    } else {
        print STDERR "failed: ", $r->code, ' ', $r->message, "\n\n";
    }
}

sub cmd_upload {
    my $dirpath;

    if (defined $_[0] and -d $_[0]) {
        $dirpath = shift;
    } elsif (-e 'log.json') {
        $dirpath = curdir();
    } else {
        print(STDERR "You need to specify a valid source directory.\n"), return;        
    }

    my $type = 'analyzed';

    if (defined $_[0] and ($_[0] eq 'new' or $_[0] eq 'analyzed')) {
        $type = shift;
    }

    my $note = join ' ', @_;
    print(STDERR "You need to specify a note.\n"), return if $note eq '';

    check_env(qw/PANLEX_ARCHIVE_USERNAME PANLEX_ARCHIVE_PASSWORD PANLEX_ARCHIVE_NAME PANLEX_ARCHIVE_EMAIL/);

    my @dirs = splitdir(rel2abs($dirpath));
    my $dirname = pop @dirs; # name of the source dir
    utf8::decode($dirname);

    chdir catdir(@dirs); # change to the parent of the source dir to get the zip archive paths right

    my $zippath = "/tmp/${dirname}.zip";
    unlink $zippath if -e $zippath;

    print STDERR "Creating $zippath ...\n";
    system('zip', '-r', $zippath, $dirname);

    my $ua = LWP::UserAgent->new;
    $ua->credentials('dev.panlex.org:80', 'PanLex resource browser', $ENV{PANLEX_ARCHIVE_USERNAME}, $ENV{PANLEX_ARCHIVE_PASSWORD});

    print STDERR "Uploading zip file ...\n";
    my $r = $ua->post("${RESOURCE_ARCHIVE_URL}/upload", 
        Content_Type => 'form-data',
        Content => [
            editor  => encode('utf8', $ENV{PANLEX_ARCHIVE_NAME}),
            email   => encode('utf8', $ENV{PANLEX_ARCHIVE_EMAIL}),
            type    => $type,
            notes   => encode('utf8', $note),
            zip     => [encode('utf8', $zippath), undef],
        ]
    );

    if ($r->is_success) {
        my $content = $r->decoded_content;

        if ($content =~ /Upload successful/) {
            print STDERR "done.\n\n";
        } else {
            print STDERR "failed: unknown error\n\n";
        }
    } else {
        print STDERR "failed: ", $r->code, ' ', $r->message, "\n\n";
    }

    unlink $zippath;
}

sub cmd_server {
    my ($port) = @_;
    $port //= 5050;
    $ENV{MOJO_MODE} = 'production';

    require PanLex::Server;

    my $app = PanLex::Server->new;
    $app->start('daemon', '-l', "http://*:$port");
}

sub usage {
    print STDERR <<EOF;
Usage: $0 <command> (<arguments> ...)

Commands:

cp <tool> (<dest>)
    copy PanLex tool into the current directory
fetch <resource_dir>|<source_label>|<source_id>
    fetch PanLex resource from archive into the current directory and unzip it
submit (<file>) (<source_id>|<source_label>) (replace|add|check)
    submit final source file to PanLem
upload (<dir>) (analyzed|new) <note>
    upload analyzed/new PanLex resource directory to archive with note
server <port>
    run HTTP server (experimental)

Environment variables:

PANLEX_TOOLDIR              panlex-tools directory path
PANLEX_ARCHIVE_USERNAME     PanLex resource archive username
PANLEX_ARCHIVE_PASSWORD     PanLex resource archive password
PANLEX_ARCHIVE_NAME         full name of PanLex editor
PANLEX_ARCHIVE_EMAIL        email of PanLex editor
PANLEX_PANLEM_USER          PanLem numeric user id
PANLEX_PANLEM_PASSWORD      PanLem hashed password

EOF
}

sub check_env {
    my %error;
    
    foreach my $var (grep { !defined $ENV{$_} } @_) {
        print STDERR "The environment variable $var must be set to execute this command.\n";
        $error{$var} = 1;
    }
    
    foreach my $dir (grep { /DIR$/ && ! -d $ENV{$_} && !$error{$_} } @_) {
        print STDERR "The environment variable $dir ($ENV{$dir}) must be set to a valid directory to execute this command.\n";
        $error{$dir} = 1;
    }
    
    keys %error > 0 && exit(0);
}

sub shell_cmd {
    my (@cmd) = @_;
    print "@cmd\n";
    return system(@cmd) >> 8;
}
